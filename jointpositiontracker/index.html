<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Proiezione Scheletro Live â€” ml5.js + p5.js</title>
  <style>
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial; margin: 0; background:#111; color:#eee; display:flex; flex-direction:column; gap:12px; align-items:center; padding:10px; }
    #canvasContainer { position:relative; border-radius:8px; overflow:hidden; box-shadow:0 6px 18px rgba(0,0,0,0.6); width:100%; max-width:100%; }
    canvas { width:100% !important; height:auto !important; display:block; }
    #controls { width:100%; background:#0f1113; padding:12px; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,0.6); box-sizing:border-box; }
    label { display:flex; gap:8px; align-items:center; margin-bottom:8px; font-size:0.9rem; }
    button { margin-top:8px; padding:10px; border-radius:6px; border: none; cursor:pointer; width:100%; background:#333; color:#eee; font-size:1rem; }
    .note { font-size:0.8rem; color:#bbb; margin-top:8px }
  </style>
</head>
<body>
  <div id="canvasContainer"></div>
  <div id="controls">
    <h3 style="margin-top:0">Controlli</h3>
    <label><input id="mirrorChk" type="checkbox" checked> Specchio (flip)</label>
    <label><input id="showKeypoints" type="checkbox" checked> Mostra punti</label>
    <label><input id="showSkeleton" type="checkbox" checked> Mostra scheletro</label>
    <label><input id="smoothChk" type="checkbox" checked> Smoothing (filtra jitter)</label>
    <label style="flex-direction:column; align-items:flex-start;">
      Dimensione pennello: <input id="strokeSize" type="range" min="1" max="6" value="2" style="width:100%">
    </label>
    <button id="snapBtn">Salva snapshot (PNG)</button>
    <div class="note">Consenti l'accesso alla fotocamera quando il browser lo chiede. Funziona meglio su Chrome/Firefox.</div>
  </div>

  <!-- p5.js e ml5.js CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ml5/0.12.2/ml5.min.js"></script>

  <script>
  let video, poseNet, poses = [], canvas;
  let mirror = true, showKeypoints = true, showSkeleton = true, smoothing = true, strokeSize = 2;
  const SMOOTH_BUFFER = 4;
  let smoothBuffer = [];

  function setup() {
    const container = document.getElementById('canvasContainer');
    const w = Math.min(window.innerWidth - 20, 640);
    const h = Math.floor(w * 3/4);
    canvas = createCanvas(w, h);
    canvas.parent(container);

    video = createCapture(VIDEO, () => console.log("Camera pronta"));
    video.size(width, height);
    video.hide(); // nascondiamo l'elemento video, useremo image(video) per mostrarlo

    const options = { architecture: 'MobileNetV1', detectionType: 'single', imageScaleFactor: 0.5, outputStride: 16, quantBytes: 2 };
    poseNet = ml5.poseNet(video, options, () => console.log('poseNet pronto'));
    poseNet.on('pose', (results) => { poses = results; if (smoothing) addToSmoothBuffer(results); });

    document.getElementById('mirrorChk').onchange = (e) => mirror = e.target.checked;
    document.getElementById('showKeypoints').onchange = (e) => showKeypoints = e.target.checked;
    document.getElementById('showSkeleton').onchange = (e) => showSkeleton = e.target.checked;
    document.getElementById('smoothChk').onchange = (e) => smoothing = e.target.checked;
    document.getElementById('strokeSize').oninput = (e) => strokeSize = parseInt(e.target.value, 10);
    document.getElementById('snapBtn').onclick = saveSnapshot;
  }

  function draw() {
    background(0);

    // Mostriamo il video sul canvas e sovrapponiamo lo scheletro
    push();
    if (mirror) { translate(width,0); scale(-1,1); }
    image(video,0,0,width,height);
    pop();

    let currentPoses = smoothing ? getSmoothedPoses() : poses;
    strokeWeight(strokeSize);
    if (currentPoses.length > 0) {
      for (let p of currentPoses) {
        if (showSkeleton && p.skeleton) drawSkeleton(p.skeleton);
        if (showKeypoints) drawKeypoints(p.pose.keypoints);
      }
    }
  }

  function drawKeypoints(keypoints) {
    for (let k of keypoints) if (k.score > 0.3) { fill(0,200,255,200); noStroke(); ellipse(k.position.x,k.position.y,8,8); }
  }

  function drawSkeleton(skel) {
    stroke(255,120,0,220);
    for (let [a,b] of skel) if (a.score>0.3 && b.score>0.3) line(a.position.x,a.position.y,b.position.x,b.position.y);
  }

  function addToSmoothBuffer(newPoses) { smoothBuffer.push(JSON.parse(JSON.stringify(newPoses))); if (smoothBuffer.length>SMOOTH_BUFFER) smoothBuffer.shift(); }
  function getSmoothedPoses(){ if(smoothBuffer.length===0)return poses; let avg=JSON.parse(JSON.stringify(smoothBuffer.at(-1))); for(let f=0;f<avg.length;f++){let pose=avg[f]; for(let k=0;k<pose.pose.keypoints.length;k++){let sx=0,sy=0,sc=0,c=0; for(let buf of smoothBuffer){let kp=buf[f]?.pose.keypoints[k]; if(kp){sx+=kp.position.x;sy+=kp.position.y;sc+=kp.score;c++;}} if(c){pose.pose.keypoints[k].position.x=sx/c;pose.pose.keypoints[k].position.y=sy/c;pose.pose.keypoints[k].score=sc/c;}}} return avg; }

  function saveSnapshot(){ saveCanvas(canvas,'skeleton_snapshot','png'); }
  </script>
</body>
</html>
